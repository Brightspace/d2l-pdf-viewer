<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<title>d2l-pdf-viewer-progress-bar tests</title>
		<meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
		<script src="../../@webcomponents/webcomponentsjs/webcomponents-bundle.js"></script>
		<script src="../../wct-browser-legacy/browser.js"></script>
		<script type="module" src="../d2l-pdf-viewer-progress-bar.js"></script>
	</head>
	<body>
		<test-fixture id="determinate-basic">
			<template strip-whitespace>
				<d2l-pdf-viewer-progress-bar></d2l-pdf-viewer-progress-bar>
			</template>
		</test-fixture>

		<test-fixture id="determinate-configured">
			<template strip-whitespace>
				<d2l-pdf-viewer-progress-bar max="20" value="5"></d2l-pdf-viewer-progress-bar>
			</template>
		</test-fixture>

		<test-fixture id="indeterminate-basic">
			<template strip-whitespace>
				<d2l-pdf-viewer-progress-bar indeterminate></d2l-pdf-viewer-progress-bar>
			</template>
		</test-fixture>

		<test-fixture id="indeterminate-autostart">
			<template strip-whitespace>
				<d2l-pdf-viewer-progress-bar indeterminate autostart></d2l-pdf-viewer-progress-bar>
			</template>
		</test-fixture>

		<script type="module">
import '../d2l-pdf-viewer-progress-bar.js';
let elem;

describe('smoke tests', () => {
	beforeEach(async () => {
		elem = fixture('indeterminate-basic');

		await elem.updateComplete;
	});

	it('should have the role "progressbar"', () => {
		expect(elem.getAttribute('role')).to.equal('progressbar');
	});
});

context('indeterminate progress', () => {
	describe('properties and attributes', () => {
		beforeEach(() => {
			elem = fixture('indeterminate-basic');
		});

		it('should not have any determine ARIA attributes set"', () => {
			expect(elem.hasAttribute('aria-valuemin')).to.be.false;
			expect(elem.hasAttribute('aria-valuemax')).to.be.false;
			expect(elem.hasAttribute('aria-valuenow')).to.be.false;
		});

		it('should default "autostart" to false', () => {
			expect(elem.autostart).to.be.false;
			expect(elem.hasAttribute('autostart')).to.be.false;
		});

		it('should reflect "autostart" property change to attribute', async () => {
			elem.autostart = true;
			await elem.updateComplete;

			expect(elem.hasAttribute('autostart')).to.be.true;
		});

		it('should reflect "autostart" attribute change to property', () => {
			elem.setAttribute('autostart', 'autostart');
			expect(elem.autostart).to.be.true;
		});
	});

	describe('default', () => {
		beforeEach(async () => {
			elem = fixture('indeterminate-basic');

			await elem.updateComplete;
		});

		it('should start when start() is called', (done) => {
			elem.start();

			setTimeout(() => {
				expect(elem._progress).to.eql(99);
				done();
			}, 100);
		});

		it('should not go to 99% if finish() is called first', (done) => {
			elem.start();
			elem.finish();

			setTimeout(() => {
				expect(elem._progress).to.eql(100);
				done();
			}, 50);
		});

	});

	describe('set', () => {
		beforeEach(async () => {
			elem = fixture('indeterminate-autostart');

			await elem.updateComplete;
		});

		it('should start on its own after 100ms', (done) => {
			setTimeout(() => {
				expect(elem._progress).to.eql(99);
				done();
			}, 100);
		});

		it('should go to 100% if finish() is called after', (done) => {
			elem.finish();
			setTimeout(() => {
				expect(elem._progress).to.eql(100);
				done();
			}, 50);
		});

		it('should have "autostart" set to true', () => {
			expect(elem.autostart).to.be.true;
			expect(elem.hasAttribute('autostart')).to.be.true;
		});
	});

	describe('starting and finishing', () => {
		beforeEach(async () => {
			elem = fixture('indeterminate-basic');

			await elem.updateComplete;
		});

		it('should not auto-start', () => {
			expect(elem._progress).to.eql(0);
		});

		it('should go to 100% when finish is called', () => {
			elem.finish();
			expect(elem._progress).to.eql(100);
		});
	});
});

context('determinate progress', () => {
	describe('properties', () => {
		beforeEach(async () => {
			elem = fixture('determinate-basic');

			await elem.updateComplete;
		});

		it('should have a default "max" of 1', () => {
			expect(elem.max).to.equal(1);
			expect(elem.getAttribute('aria-valuemax')).to.equal('1');
		});

		it('should have a default "value" of 0', () => {
			expect(elem.value).to.equal(0);
			expect(elem.getAttribute('aria-valuenow')).to.equal('0');
		});

		it('should reflect "max" as "aria-valuemax" when set by property', async () => {
			elem.max = 1234;

			await elem.updateComplete;

			expect(elem.getAttribute('aria-valuemax')).to.equal('1234');
		});

		it('should reflect "value" as "aria-valuenow" when set by property', async () => {
			elem.value = 0.5;

			await elem.updateComplete;

			expect(elem.getAttribute('aria-valuenow')).to.equal('0.5');
		});

		it('should clamp "aria-valuenow" if greater than "max"', async () => {
			elem.value = 1000;

			await elem.updateComplete;

			expect(elem.getAttribute('aria-valuenow')).to.equal('1');
		});

		it('should reset "max" to 1 if invalid', async () => {
			elem.max = 0;

			await elem.updateComplete;

			expect(elem.max).to.equal(1);
			expect(elem.getAttribute('aria-valuemax')).to.equal('1');
		});
	});

	describe('attributes', () => {
		beforeEach(async () => {
			elem = fixture('determinate-configured');

			await elem.updateComplete;
		});

		it('should reflect "max" as "aria-valuemax" when set by attribute', () => {
			expect(elem.getAttribute('aria-valuemax')).to.equal('20');
		});

		it('should reflect "value" as "aria-valuenow" when set by attribute', () => {
			expect(elem.getAttribute('aria-valuenow')).to.equal('5');
		});
	});

	describe('starting and finishing', () => {
		beforeEach(async () => {
			elem = fixture('determinate-basic');

			await elem.updateComplete;
		});

		it('should not auto-start', () => {
			expect(elem._indeterminateState).to.eql(0);
		});
	});
});
</script>
	</body>
</html>
